require 'procps/column'
require 'procps/column_types/command'
require 'procps/column_types/memsize'
require 'procps/column_types/scheduling_policy'

module Procps
  class PS
    Address    = -> (base = 10, null: "-".freeze) { -> (v) { v.is_a?(String) ? v == null ? nil : v.to_i(base) : v } }
    Address_10 = Address[]
    Address_16 = Address[16]

    @@columns = {
      :blocked    => Column.new("BLOCKED"),
      :bsdstart   => Column.new("START"),
      :bsdtime    => Column.new("TIME"),
      :c          => Column.new("C", &:to_f),
      :caught     => Column.new("CAUGHT"),
      :cgroup     => Column.new("CGROUP"),
      :cls        => Column.new("CLS", SchedulingPolicy),
      :cmd        => Column.new("CMD", Command),
      :comm       => Column.new("COMMAND"),
      :command    => Column.new("COMMAND", Command),
      :cp         => Column.new("CP") { |v| v.to_f / 100_0 }, # tenths of a percent
      :egid       => Column.new("EGID", &:to_i),
      :egroup     => Column.new("EGROUP"),
      :eip        => Column.new("EIP"),
      :esp        => Column.new("ESP"),
      :etime      => Column.new("ELAPSED"),
      :etimes     => Column.new("ELAPSED", &:to_i),
      :f          => Column.new("F", &:to_i),
      :fgid       => Column.new("FGID", &:to_i),
      :fgroup     => Column.new("FGROUP"),
      :fname      => Column.new("FNAME"),
      :fuid       => Column.new("FUID", &:to_i),
      :fuser      => Column.new("FUSER"),
      :gid        => Column.new("GID", &:to_i),
      :group      => Column.new("GROUP"),
      :ignored    => Column.new("IGNORED"),
      :ipcns      => Column.new("IPCNS", Address_10),
      :label      => Column.new("LABEL"),
      :lstart     => Column.new("STARTED"),
      :lsession   => Column.new("SESSION"),
      :lwp        => Column.new("LWP", &:to_i),
      :machine    => Column.new("MACHINE"),
      :maj_flt    => Column.new("MAJFLT"),
      :min_flt    => Column.new("MINFLT"),
      :mntns      => Column.new("MNTNS", Address_10),
      :netns      => Column.new("NETNS", Address_10),
      :ni         => Column.new("NI", &:to_i),
      :nlwp       => Column.new("NLWP", &:to_i),
      :nwchan     => Column.new("WCHAN", Address_16),
      :ouid       => Column.new("OWNER", &:to_i),
      :pending    => Column.new("PENDING"),
      :pcpu       => Column.new("%CPU", &:to_f),
      :pgid       => Column.new("PGID", &:to_i),
      :pgrp       => Column.new("PGRP", &:to_i),
      :pid        => Column.new("PID", &:to_i),
      :pidns      => Column.new("PIDNS", &:to_i),
      :pmem       => Column.new("%MEM", &:to_f),
      :policy     => Column.new("POL", SchedulingPolicy),
      :ppid       => Column.new("PPID", &:to_i),
      :pri        => Column.new("PRI", &:to_i),
      :psr        => Column.new("PSR", &:to_i),
      :rgid       => Column.new("RGID", &:to_i),
      :rgroup     => Column.new("RGROUP"),
      :rss        => Column.new("RSS", Memsize),
      :rtprio     => Column.new("RTPRIO", Address_10),
      :ruid       => Column.new("RUID", &:to_i),
      :ruser      => Column.new("RUSER"),
      :s          => Column.new("S"),
      :sched      => Column.new("SCH") { |v| SchedulingPolicy.(v.to_i) },
      :seat       => Column.new("SEAT"),
      :sess       => Column.new("SESS", &:to_i),
      :sgi_p      => Column.new("SGI_P", Address[null: "*".freeze]),
      :sgid       => Column.new("SGID", &:to_i),
      :sgroup     => Column.new("SGROUP"),
      :sid        => Column.new("SID", &:to_i),
      :size       => Column.new("SIZE", &:to_i),
      :slice      => Column.new("SLICE"),
      :spid       => Column.new("SPID", &:to_i),
      :stackp     => Column.new("STACKP", Address_16),
      :start      => Column.new("STARTED"),
      :start_time => Column.new("START_TIME"),
      :stat       => Column.new("STAT"),
      :suid       => Column.new("SUID", &:to_i),
      :suser      => Column.new("SUSER"),
      :supgid     => Column.new("SUPGID", &:to_i),
      :supgrp     => Column.new("SUPGRP"),
      :svgid      => Column.new("SVGID", &:to_i),
      :svuid      => Column.new("SVUID", &:to_i),
      :sz         => Column.new("SZ", &:to_i),
      :tgid       => Column.new("TGID", &:to_i),
      :thcount    => Column.new("THCNT", &:to_i),
      :tid        => Column.new("TID", &:to_i),
      :time       => Column.new("TIME"),
      :tname      => Column.new("TTY"),
      :tpgid      => Column.new("TPGID", &:to_i),
      :tt         => Column.new("TT"),
      :ucmd       => Column.new("CMD"),
      :uid        => Column.new("UID", &:to_i),
      :unit       => Column.new("UNIT"),
      :user       => Column.new("USER"),
      :userns     => Column.new("USERNS", &:to_i),
      :utsns      => Column.new("UTSNS", &:to_i),
      :uunit      => Column.new("UUNIT"),
      :vsz        => Column.new("VSZ", Memsize)
    }.tap do |cols|
      cols.update(
        :'%cpu'     => cols.fetch(:pcpu),
        :'%mem'     => cols.fetch(:pmem),
        :args       => cols.fetch(:command),
        :class      => cols.fetch(:cls),
        :cputime    => cols.fetch(:time),
        :flag       => cols.fetch(:f),
        :flags      => cols.fetch(:f),
        :nice       => cols.fetch(:ni),
        :rssize     => cols.fetch(:rss),
        :rsz        => cols.fetch(:rss),
        :sig        => cols.fetch(:pending),
        :sig_block  => cols.fetch(:blocked),
        :sigmask    => cols.fetch(:blocked),
        :sig_catch  => cols.fetch(:caught),
        :sigcatch   => cols.fetch(:caught),
        :sig_ignore => cols.fetch(:ignored),
        :sigignore  => cols.fetch(:ignored),
        :state      => cols.fetch(:s),
        :tty        => cols.fetch(:tt),
        :ucomm      => cols.fetch(:comm),
        :uname      => cols.fetch(:user),
        :vsize      => cols.fetch(:vsz)
      )
    end

    def self.columns
      @@columns
    end
  end
end
